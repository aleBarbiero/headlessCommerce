"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
// import "cross-fetch/polyfill";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const path_1 = tslib_1.__importDefault(require("path"));
const bearerToken_1 = require("./bearerToken");
const exchangeTools_1 = require("./exchangeTools");
const logger_1 = require("../common/logger");
const DEFAULT_DOWNLOAD_FOLDER = "download";
const ANYPOINT_BASE_URI = "https://anypoint.mulesoft.com/exchange/api/v2";
const ANYPOINT_BASE_URI_WITHOUT_VERSION = "https://anypoint.mulesoft.com/exchange";
function downloadRestApi(restApi, destinationFolder = DEFAULT_DOWNLOAD_FOLDER) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!restApi.id) {
            logger_1.ramlToolLogger.warn(`Failed to download '${restApi.name}' RAML as Fat RAML download information is missing.`, `Please download it manually from ${ANYPOINT_BASE_URI_WITHOUT_VERSION}/${restApi.groupId}/${restApi.assetId} and update the relevant details in apis/api-config.json`);
            return;
        }
        yield fs_extra_1.default.ensureDir(destinationFolder);
        const zipFilePath = path_1.default.join(destinationFolder, `${restApi.assetId}.zip`);
        const response = yield node_fetch_1.default(restApi.fatRaml.externalLink);
        const arrayBuffer = yield response.arrayBuffer();
        yield fs_extra_1.default.writeFile(zipFilePath, Buffer.from(arrayBuffer));
        return response;
    });
}
exports.downloadRestApi = downloadRestApi;
function downloadRestApis(restApi, destinationFolder = DEFAULT_DOWNLOAD_FOLDER) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const downloads = restApi.map(api => downloadRestApi(api, destinationFolder));
        yield Promise.all(downloads);
        return destinationFolder;
    });
}
exports.downloadRestApis = downloadRestApis;
function mapCategories(categories) {
    const cats = {};
    categories.forEach(category => {
        cats[category.key] = category.value;
    });
    return cats;
}
function getFileByClassifier(files, classifier) {
    const found = files.find(file => file.classifier === classifier);
    // There are extra properties we don't want (downloadURL, isGenerated), so we
    // create a new object that excludes them
    return {
        classifier: found.classifier,
        packaging: found.packaging,
        externalLink: found.externalLink,
        createdDate: found.createdDate,
        md5: found.md5,
        sha1: found.sha1,
        mainFile: found.mainFile
    };
}
function convertResponseToRestApi(apiResponse) {
    return {
        id: apiResponse.id,
        name: apiResponse.name,
        description: apiResponse.description,
        updatedDate: apiResponse.updatedDate,
        groupId: apiResponse.groupId,
        assetId: apiResponse.assetId,
        version: apiResponse.version,
        categories: mapCategories(apiResponse.categories),
        fatRaml: getFileByClassifier(apiResponse.files, "fat-raml")
    };
}
/**
 * @description Get an asset from exchange.  This can be any of the following patterns
 *  * /groupId/assetId/version
 *  * /groupId/assetId
 *  * /groupId
 *
 * @export
 * @param {string} accessToken
 * @param {string} assetId
 * @returns {Promise<void | RawRestApi>}
 */
function getAsset(accessToken, assetId) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const res = yield node_fetch_1.default(`${ANYPOINT_BASE_URI}/assets/${assetId}`, {
            headers: {
                Authorization: `Bearer ${accessToken}`
            }
        });
        if (!res.ok) {
            logger_1.ramlToolLogger.warn(`Failed to get information about ${assetId} from exchange: ${res.status} - ${res.statusText}`, `Please get it manually from ${ANYPOINT_BASE_URI}/assets/${assetId} and update the relevant details in apis/api-config.json`);
            return;
        }
        return res.json();
    });
}
exports.getAsset = getAsset;
/**
 * @description Searches exchange and gets a list of apis based on the search string
 * @export
 * @param {string} accessToken
 * @param {string} searchString
 * @returns {Promise<RestApi[]>}
 */
function searchExchange(accessToken, searchString) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return node_fetch_1.default(`${ANYPOINT_BASE_URI}/assets?search=${searchString}&types=rest-api`, {
            headers: {
                Authorization: `Bearer ${accessToken}`
            }
        })
            .then(res => res.json())
            .then(restApis => {
            const apis = [];
            restApis.forEach(restApi => {
                apis.push(convertResponseToRestApi(restApi));
            });
            return apis;
        });
    });
}
exports.searchExchange = searchExchange;
/**
 * @description Looks at all versions of an api in exchange for an instance that matched the deployment regex
 *
 * @export
 * @param {string} accessToken
 * @param {RestApi} restApi
 * @param {RegExp} deployment
 * @returns {Promise<string>} Returned the version string that matches the regex passed.  Will return first found result
 */
function getVersionByDeployment(accessToken, restApi, deployment) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const asset = yield getAsset(accessToken, `${restApi.groupId}/${restApi.assetId}`);
        if (!asset) {
            return;
        }
        let version = null;
        asset.instances.forEach(instance => {
            if (instance.environmentName &&
                deployment.test(instance.environmentName) &&
                !version) {
                version = instance.version;
            }
        });
        // If no instance matched the intended deployment get the version info
        // from the fetched asset.
        return version || asset.version;
    });
}
exports.getVersionByDeployment = getVersionByDeployment;
/**
 * @description Gets details on a very specific api version combination
 * @export
 * @param {string} accessToken
 * @param {string} groupId
 * @param {string} assetId
 * @param {string} version
 * @returns {Promise<RestApi>}
 */
function getSpecificApi(accessToken, groupId, assetId, version) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!version)
            return null;
        const api = yield getAsset(accessToken, `${groupId}/${assetId}/${version}`);
        return api ? convertResponseToRestApi(api) : null;
    });
}
exports.getSpecificApi = getSpecificApi;
/**
 * Gets information about all the APIs from exchange that match the given search
 * string for the version deployed in the given environment.
 * If it fails to get information about the deployed version of an API, it
 * removes all the version specific information from the returned object.
 *
 * @param query - Exchange search query
 * @param deployment - RegExp matching the desired deployment targets
 *
 * @returns Information about the APIs found.
 */
function search(query, deployment) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const token = yield bearerToken_1.getBearer(process.env.ANYPOINT_USERNAME, process.env.ANYPOINT_PASSWORD);
        const apis = yield searchExchange(token, query);
        const promises = apis.map((api) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const version = yield getVersionByDeployment(token, api, deployment);
            return version
                ? getSpecificApi(token, api.groupId, api.assetId, version)
                : exchangeTools_1.removeVersionSpecificInformation(api);
        }));
        return Promise.all(promises);
    });
}
exports.search = search;
//# sourceMappingURL=exchangeDownloader.js.map