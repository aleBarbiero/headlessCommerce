"use strict";
/*
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const amf_client_js_1 = require("amf-client-js");
const amf_client_js_2 = tslib_1.__importDefault(require("amf-client-js"));
const path_1 = tslib_1.__importDefault(require("path"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const resourceLoaders_1 = require("./resourceLoaders");
/**
 * Parses a RAML file to an AMF model.
 *
 * @param filename The path to the RAML file to load
 *
 * @returns an AMF model of the RAML
 */
function parseRamlFile(filename) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const fileUri = `file://${path_1.default.resolve(filename)}`;
        // We initialize AMF first
        amf_client_js_2.default.plugins.document.WebApi.register();
        amf_client_js_2.default.plugins.document.Vocabularies.register();
        amf_client_js_2.default.plugins.features.AMFValidation.register();
        yield amf_client_js_2.default.Core.init();
        const fatRamlResourceLoader = new resourceLoaders_1.FatRamlResourceLoader(path_1.default.dirname(fileUri));
        const ccEnvironment = amf_client_js_2.default.client.DefaultEnvironment.apply().addClientLoader(fatRamlResourceLoader);
        const parser = new amf_client_js_2.default.Raml10Parser(ccEnvironment);
        return parser.parseFileAsync(fileUri);
    });
}
exports.parseRamlFile = parseRamlFile;
function getDataTypesFromDeclare(types, existingDataTypes) {
    const ret = [];
    types.forEach((dataType) => {
        if (!existingDataTypes.has(dataType.name.value()) &&
            dataType.name.value() !== "trait") {
            existingDataTypes.add(dataType.name.value());
            ret.push(dataType);
        }
    });
    return ret;
}
/**
 * Get all the referenced data types
 *
 * @param apiReferences - Array of references
 * @param dataTypes - Array of data types
 * @param existingDataTypes - Set of names of data types, used to de-duplicate the data types
 */
function getReferenceDataTypes(apiReferences, dataTypes, existingDataTypes) {
    if (apiReferences == null || apiReferences.length == 0) {
        return;
    }
    apiReferences.forEach(
    // reference could actually be BaseUnit or BaseUnitWithDeclaresModel
    (reference) => {
        if (reference.declares) {
            dataTypes.push(...getDataTypesFromDeclare(reference.declares, existingDataTypes));
        }
        getReferenceDataTypes(reference.references(), dataTypes, existingDataTypes);
    });
}
exports.getReferenceDataTypes = getReferenceDataTypes;
/**
 * Extract all of the delcared data types from an AMF model.
 *
 * @param api - The model to extract data types from
 *
 * @returns data types from model
 */
function getAllDataTypes(api) {
    let ret = [];
    const dataTypes = new Set();
    const temp = getDataTypesFromDeclare(api.declares, dataTypes);
    if (temp != null) {
        ret = temp;
    }
    getReferenceDataTypes(api.references(), ret, dataTypes);
    return ret;
}
exports.getAllDataTypes = getAllDataTypes;
/**
 * Resolves the AMF model using the given resolution pipeline
 *
 * @param apiModel - AMF model of the API
 * @param resolutionPipeline - resolution pipeline.
 *
 * @returns AMF model after resolving with the given pipeline
 */
function resolveApiModel(apiModel, resolutionPipeline) {
    /**
     * TODO: core.resolution.pipelines.ResolutionPipeline has all the pipelines defined but is throwing an error when used - "Cannot read property 'pipelines' of undefined".
     *  When this is fixed we should change the type of input param "resolutionPipeline"
     */
    if (apiModel == null) {
        throw new Error("Invalid API model provided to resolve");
    }
    if (resolutionPipeline == null) {
        throw new Error("Invalid resolution pipeline provided to resolve");
    }
    const resolver = new amf_client_js_1.Raml10Resolver();
    return resolver.resolve(apiModel, resolutionPipeline);
}
exports.resolveApiModel = resolveApiModel;
/**
 * Get normalized name for the file/directory that is created while rendering the templates
 *
 * @param name - File or directory name to normalize
 * @returns a normalized name
 */
function getNormalizedName(name) {
    if (!name) {
        throw new Error("Invalid name provided to normalize");
    }
    return lodash_1.default.camelCase(name);
}
exports.getNormalizedName = getNormalizedName;
/**
 * Returns API name from the AMF model in Pascal Case ("Shopper Customers" is returned as "ShopperCustomers")
 *
 * @param apiModel - AMF Model of the API
 * @returns Name of the API
 */
function getApiName(apiModel) {
    const apiName = apiModel.encodes.name.value();
    return getNormalizedName(apiName);
}
exports.getApiName = getApiName;
//# sourceMappingURL=parser.js.map