"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
exports.getValue = utils_1.getValue;
const amf_client_js_1 = require("amf-client-js");
/**
 * Get the baseUri from an AMF model.
 *
 * Note: TypeScript will not allow access to the data without the proper cast to
 * a WebApi type.
 *
 * @param property - A model from the the AMF parser
 *
 * @returns the base URI of the model
 */
exports.getBaseUriFromDocument = (property) => {
    return property && property.encodes
        ? property.encodes.servers[0].url.value()
        : "";
};
/**
 * Check if the specified AMF domain element is a type definition or not.
 *
 * @param domainElement - The domain element to be evaluated
 *
 * @returns true if the domain element is a type definition, false if not
 */
exports.isTypeDefinition = (domainElement) => {
    return domainElement instanceof amf_client_js_1.model.domain.NodeShape;
};
/**
 * Get the return type info of an operation.
 *
 * @param operation - An AMF operation
 *
 * @returns a string for the data type returned by the successful operation
 */
exports.getReturnTypeFromOperation = (operation) => {
    const okResponses = utils_1.getResponsesFromPayload(operation);
    const dataTypes = [];
    okResponses.forEach(res => {
        if (res.payloads.length > 0) {
            dataTypes.push(utils_1.getTypeFromPayload(res.payloads[0]));
        }
        else {
            dataTypes.push("void");
        }
    });
    if (okResponses.length === 0) {
        dataTypes.push("void");
    }
    return dataTypes.join(" | ");
};
/**
 * Get data type of a property.
 *
 * @param property - An AMF property
 *
 * @returns data type, if defined in the property, the default type otherwise
 */
exports.getTypeFromProperty = (property) => {
    if (property != null && property.range != null) {
        return utils_1.getDataType(property.range);
    }
    return utils_1.DEFAULT_DATA_TYPE;
};
/**
 * Get data type of a parameter.
 *
 * @param param - An AMF parameter
 *
 * @returns data type, if defined in the parameter, the default type otherwise
 */
exports.getTypeFromParameter = (param) => {
    if (param != null && param.schema != null) {
        return utils_1.getDataType(param.schema);
    }
    return utils_1.DEFAULT_DATA_TYPE;
};
/**
 * Get payload type from the request.
 *
 * @param request - An AMF request
 *
 * @returns Type of the request body
 */
exports.getPayloadTypeFromRequest = (request) => {
    if (request != null &&
        request.payloads != null &&
        request.payloads.length > 0) {
        const payloadSchema = request.payloads[0].schema;
        if (payloadSchema instanceof amf_client_js_1.model.domain.ArrayShape) {
            return utils_1.ARRAY_DATA_TYPE.concat("<")
                .concat(utils_1.getTypeFromShape(payloadSchema.items))
                .concat(">");
        }
        return utils_1.getTypeFromShape(payloadSchema);
    }
    return utils_1.OBJECT_DATA_TYPE;
};
/**
 * Get all the properties of an AMF node.
 *
 * @param node - An AMF node
 *
 * @returns Array of properties in the node that are not regular expressions
 */
exports.getProperties = (node) => {
    return utils_1.getFilteredProperties(node, propertyName => {
        return !/^([/^]).*.$/.test(propertyName);
    });
};
/**
 * Check if the property is defined as required.
 * Required properties have minimum count of at least 1
 * We ignore required additional properties because of the
 * different semantics used in rendering those properties.
 *
 * @param property - An AMF property
 *
 * @returns true if the property is required, false otherwise
 */
exports.isRequiredProperty = (property) => {
    return property != null && property.minCount.value() > 0;
};
/**
 * Check if the property is optional.
 * Optional properties have minimum count of 0
 * We ignore optional additional properties which also have minimum count of 0,
 * because of the different semantics used in rendering those properties.
 *
 * @param property - An AMF property
 *
 * @returns true if the property is optional, false otherwise
 */
exports.isOptionalProperty = (property) => {
    return property != null && property.minCount.value() == 0;
};
/**
 * Check if additional properties are allowed for a given AMF node or not.
 *
 * @param node - An AMF node
 *
 * @returns true if additional properties are allowed, false otherwise
 */
exports.isAdditionalPropertiesAllowed = (node) => {
    return (node !== undefined &&
        node.closed !== undefined &&
        node.closed.value !== undefined &&
        !node.closed.value());
};
//# sourceMappingURL=handlebarsAmfHelpers.js.map