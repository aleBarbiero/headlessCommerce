"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
const amf_client_js_1 = require("amf-client-js");
exports.ARRAY_DATA_TYPE = "Array";
exports.DEFAULT_DATA_TYPE = "any";
exports.OBJECT_DATA_TYPE = "object";
exports.PRIMITIVE_DATA_TYPE_MAP = {
    "http://www.w3.org/2001/XMLSchema#string": "string",
    "http://www.w3.org/2001/XMLSchema#integer": "number",
    "http://www.w3.org/2001/XMLSchema#double": "number",
    "http://www.w3.org/2001/XMLSchema#float": "number",
    "http://www.w3.org/2001/XMLSchema#boolean": "boolean"
};
/**
 * Get responses from the given operation object.
 *
 * @param operation - An AMF operation
 *
 * @returns An array of responses extracted from the given operation
 */
exports.getResponsesFromPayload = (operation) => {
    const okResponses = [];
    for (const res of operation.responses) {
        if (res.statusCode.nonEmpty && res.statusCode.value().startsWith("2")) {
            okResponses.push(res);
        }
    }
    return okResponses;
};
/**
 * Get types from the given payload.
 *
 * @param payload - Contains schema(s) from which to extract the type(s).
 *
 * @returns string representation of the data types in the payload
 */
exports.getTypeFromPayload = (payload) => {
    if (payload.schema.name.value() === "schema") {
        return "Object";
    }
    if (payload.schema.anyOf !== undefined) {
        const union = [];
        payload.schema.anyOf.forEach(element => {
            union.push(element.name.value());
        });
        return union.join(" | ");
    }
    return payload.schema.name.value();
};
/**
 * Get data type for the given namespaced data type.
 *
 * @param nsDataType - A namespaced datatype e.g. http://www.w3.org/2001/XMLSchema#string
 *
 * @returns a regular javascript type
 */
exports.getDataTypeFromMap = (nsDataType) => {
    return exports.PRIMITIVE_DATA_TYPE_MAP[nsDataType]
        ? exports.PRIMITIVE_DATA_TYPE_MAP[nsDataType]
        : exports.DEFAULT_DATA_TYPE;
};
/**
 * Get data type from a ScalarShape object.
 *
 * @param scalarShape - A ScalarShape object
 *
 * @returns scalar data type if defined otherwise returns a default type
 */
exports.getScalarType = (scalarShape) => {
    let dataType = undefined;
    if (scalarShape.dataType != null) {
        const typeValue = scalarShape.dataType.value();
        if (typeValue != null) {
            dataType = exports.getDataTypeFromMap(typeValue);
        }
    }
    //check if the type is linked to another scalar type
    if (dataType == null &&
        scalarShape.isLink === true &&
        scalarShape.linkTarget != null) {
        dataType = exports.getScalarType(scalarShape.linkTarget);
    }
    if (dataType == null) {
        dataType = exports.DEFAULT_DATA_TYPE;
    }
    return dataType;
};
/**
 * Get data type that is linked/inherited.
 *
 * @param anyShape - instance of model.domain.AnyShape or its subclass
 *
 * @returns linked/inherited data type
 */
exports.getLinkedType = (anyShape) => {
    let linkedType = undefined;
    let dataType = undefined;
    //check if type is inherited
    if (anyShape.inherits != null && anyShape.inherits.length > 0) {
        if (anyShape.inherits[0] != null &&
            anyShape.inherits[0].isLink === true &&
            anyShape.inherits[0].linkTarget != null) {
            linkedType = anyShape.inherits[0].linkTarget;
        }
    }
    //check if type is linked
    if (linkedType == null &&
        anyShape.isLink === true &&
        anyShape.linkTarget != null) {
        linkedType = anyShape.linkTarget;
    }
    if (linkedType != null &&
        linkedType instanceof amf_client_js_1.model.domain.AnyShape &&
        linkedType.name != null) {
        const temp = linkedType.name.value();
        if (temp != null) {
            dataType = temp;
        }
    }
    return dataType;
};
/**
 * Get object type
 *
 * @param anyShape - instance of model.domain.AnyShape or its subclass
 *
 * @returns object type if defined otherwise returns a default type
 */
exports.getObjectType = (anyShape) => {
    let dataType = exports.getLinkedType(anyShape);
    if (dataType == null) {
        if (anyShape instanceof amf_client_js_1.model.domain.NodeShape &&
            anyShape.properties != null) {
            dataType = exports.OBJECT_DATA_TYPE;
        }
        else {
            dataType = exports.DEFAULT_DATA_TYPE;
        }
    }
    return dataType;
};
/* eslint-disable @typescript-eslint/no-use-before-define */
/**
 * Get data type of an element from AMF model.
 *
 * @param domainElement - An AMF DomainElement or its subclass
 *
 * @returns data type if defined otherwise returns a default type
 */
exports.getDataType = (domainElement) => {
    let dataType = undefined;
    if (domainElement != null) {
        if (domainElement instanceof amf_client_js_1.model.domain.ScalarShape) {
            dataType = exports.getScalarType(domainElement);
        }
        else if (domainElement instanceof amf_client_js_1.model.domain.ArrayShape) {
            dataType = getArrayType(domainElement);
        }
        else if (domainElement instanceof amf_client_js_1.model.domain.AnyShape) {
            dataType = exports.getObjectType(domainElement);
        }
    }
    if (dataType == null) {
        dataType = exports.DEFAULT_DATA_TYPE;
    }
    return dataType;
};
/**
 * Get type of the array.
 *
 * @param arrayShape - An AMF ArrayShape
 *
 * @returns array type if defined otherwise returns a default type
 */
const getArrayType = (arrayShape) => {
    let arrItem = arrayShape.items;
    if (arrItem == null) {
        if (arrayShape.inherits != null && arrayShape.inherits.length > 0)
            arrItem = arrayShape.inherits[0].items;
    }
    return exports.ARRAY_DATA_TYPE.concat("<")
        .concat(exports.getDataType(arrItem))
        .concat(">");
};
/**
 * Get type of AMF Shape object.
 *
 * @param shape - An AMF Shape object
 *
 * @returns 'object' if the name property of the Shape is null or 'schema', the
 * name itself otherwise
 *
 */
exports.getTypeFromShape = (shape) => {
    const name = shape.name.value();
    if (name == null || name === "schema") {
        return exports.OBJECT_DATA_TYPE;
    }
    return name;
};
/**
 * Get value from an AMF field.
 *
 * @param name - The field to extract the value from
 *
 * @returns The string of the value
 */
exports.getValue = (name) => {
    var _a;
    let value;
    if (typeof ((_a = name) === null || _a === void 0 ? void 0 : _a.value) === "function") {
        value = name.value();
    }
    return value == null ? null : `${value}`;
};
/**
 * Get properties of a node (inherited and linked) after applying the given filter criteria
 *
 * @param node - An AMF node
 * @param propertyFilter - predicate to be used to filter properties
 *
 * @returns The filtered list of properties
 */
exports.getFilteredProperties = (node, propertyFilter) => {
    const properties = [];
    const existingProps = new Set();
    while (node != null) {
        if (node.properties != null && node.properties.length > 0) {
            node.properties.forEach(prop => {
                if (prop != null) {
                    const propName = exports.getValue(prop.name);
                    //ignore duplicate props
                    if (propName != null &&
                        !existingProps.has(propName) &&
                        propertyFilter(propName) === true) {
                        existingProps.add(propName);
                        properties.push(prop);
                    }
                }
            });
            //Check if there are any inherited properties
            if (node.inherits != null && node.inherits.length > 0) {
                node = node.inherits[0];
            }
            else {
                node = null;
            }
        }
        else if (node.isLink === true && node.linkTarget != null) {
            //check if other DTO is linked
            node = node.linkTarget;
        }
        else {
            node = null;
        }
    }
    return properties;
};
//# sourceMappingURL=utils.js.map