/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CacheManagerRedis = void 0;
const tslib_1 = require("tslib");
const ioredis_1 = tslib_1.__importDefault(require("ioredis"));
const redis_1 = tslib_1.__importDefault(require("@keyv/redis"));
const cacheManagerKeyv_1 = require("./cacheManagerKeyv");
/**
 * This is an implementation of the Cache standard for make-fetch-happen using
 * the Keyv storage interface to write to Redis.
 * docs: https://developer.mozilla.org/en-US/docs/Web/API/Cache
 * https://www.npmjs.com/package/keyv
 */
class CacheManagerRedis extends cacheManagerKeyv_1.CacheManagerKeyv {
    constructor(options) {
        if (options === null || options === void 0 ? void 0 : options.clusterConfig) {
            // TODO: Remove workaround when cluster support is added (hopefully soon):
            // https://github.com/lukechilds/keyv-redis/pull/37
            // The workaround below can be replaced with the following code:
            // options.keyvStore = new KeyvRedis(
            //   new Redis.Cluster(options.clusterConfig)
            // );
            // KeyvRedis does not directly support Redis clusters, but clusters have
            // the same interface as normal Redis instances, so we can pass a Redis
            // instance to the constructor and then replace it with a cluster.
            // If we don't pass a Redis instance to KeyvRedis, it will create one by
            // default and attempt to connect. By passing our own instance, we can set
            // lazyConnect and avoid connecting to something unknown/missing.
            const keyvStore = new redis_1.default(new ioredis_1.default({ lazyConnect: true }));
            keyvStore.redis = new ioredis_1.default.Cluster(options.clusterConfig);
            // Copied from KeyvRedis constructor
            keyvStore.redis.on("error", keyvStore.emit.bind(keyvStore, "error"));
            options.keyvStore = keyvStore;
        }
        super(options);
    }
    /**
     * Redis will attempt to maintain an active connection which prevents Node.js
     * from exiting. Call this to gracefully close the connection.
     *
     * @returns true for successful disconnection
     */
    quit() {
        var _a, _b, _c, _d;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (yield ((_d = (_c = (_b = (_a = this.keyv) === null || _a === void 0 ? void 0 : _a.opts) === null || _b === void 0 ? void 0 : _b.store) === null || _c === void 0 ? void 0 : _c.redis) === null || _d === void 0 ? void 0 : _d.quit())) === "OK";
        });
    }
}
exports.CacheManagerRedis = CacheManagerRedis;
//# sourceMappingURL=cacheManagerRedis.js.map