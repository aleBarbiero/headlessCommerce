"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCallGraph = exports.getClassPerJarMapping = exports.getTargets = void 0;
const tslib_1 = require("tslib");
require("source-map-support/register");
const jszip = require("jszip");
const path = require("path");
const config = require("./config");
const sub_process_1 = require("./sub-process");
const fetch_snyk_java_call_graph_generator_1 = require("./fetch-snyk-java-call-graph-generator");
const call_graph_1 = require("./call-graph");
const promisified_fs_glob_1 = require("./promisified-fs-glob");
const class_parsing_1 = require("./class-parsing");
const metrics_1 = require("./metrics");
const debug_1 = require("./debug");
function getCallGraphGenCommandArgs(classPath, jarPath, targets) {
    return [
        '-cp',
        jarPath,
        'io.snyk.callgraph.app.App',
        '--application-classpath',
        classPath,
        '--dirs-to-get-entrypoints',
        targets.join(','),
    ];
}
function runJavaCommand(javaCommandArgs, targetPath, timeout) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        debug_1.debug(`executing java command: "java ${javaCommandArgs.join(' ')}"`);
        return sub_process_1.execute('java', javaCommandArgs, {
            cwd: targetPath,
            timeout,
        });
    });
}
function getTargets(targetPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const targetDirs = yield promisified_fs_glob_1.glob(path.join(targetPath, '**/target'));
        if (!targetDirs.length) {
            throw new Error('Could not find a target folder');
        }
        return targetDirs;
    });
}
exports.getTargets = getTargets;
function getClassPerJarMapping(classPath) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const classPerJarMapping = {};
        for (const classPathItem of classPath.split(':')) {
            // classpath can also contain local directories with classes - we don't need them for package mapping
            if (!classPathItem.endsWith('.jar')) {
                continue;
            }
            const jarFileContent = yield promisified_fs_glob_1.readFile(classPathItem);
            const jarContent = yield jszip.loadAsync(jarFileContent);
            for (const classFile of Object.keys(jarContent.files).filter((name) => name.endsWith('.class'))) {
                const className = class_parsing_1.toFQclassName(classFile.replace('.class', '')); // removing .class from name
                classPerJarMapping[className] = classPathItem;
            }
        }
        return classPerJarMapping;
    });
}
exports.getClassPerJarMapping = getClassPerJarMapping;
function getCallGraph(classPath, targetPath, timeout) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const jarPath = yield fetch_snyk_java_call_graph_generator_1.fetch(config.CALL_GRAPH_GENERATOR_URL, config.CALL_GRAPH_GENERATOR_CHECKSUM);
        const targets = yield metrics_1.timeIt('getEntrypoints', () => getTargets(targetPath));
        const callgraphGenCommandArgs = getCallGraphGenCommandArgs(classPath, jarPath, targets);
        try {
            const javaOutput = yield metrics_1.timeIt('generateCallGraph', () => runJavaCommand(callgraphGenCommandArgs, targetPath, timeout));
            const classPerJarMapping = yield metrics_1.timeIt('mapClassesPerJar', () => getClassPerJarMapping(classPath));
            return call_graph_1.buildCallGraph(javaOutput, classPerJarMapping);
        }
        catch (e) {
            throw new Error(`java command 'java ${callgraphGenCommandArgs.join(' ')} failed with error: ${e}`);
        }
    });
}
exports.getCallGraph = getCallGraph;
//# sourceMappingURL=java-wrapper.js.map