"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._put = exports._post = exports._patch = exports._delete = exports._get = exports.logResponse = exports.logFetch = exports.getObjectFromResponse = exports.ResponseError = exports.Response = exports.DefaultCache = void 0;
const tslib_1 = require("tslib");
/*
 * Copyright (c) 2019, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: BSD-3-Clause
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const make_fetch_happen_1 = tslib_1.__importStar(require("make-fetch-happen"));
Object.defineProperty(exports, "Response", { enumerable: true, get: function () { return make_fetch_happen_1.Response; } });
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const fetch_to_curl_1 = tslib_1.__importDefault(require("fetch-to-curl"));
const DefaultCache = require("make-fetch-happen/cache");
exports.DefaultCache = DefaultCache;
const minipass_fetch_1 = require("minipass-fetch");
const resource_1 = require("./resource");
const sdkLogger_1 = require("./sdkLogger");
const ioredis_1 = tslib_1.__importDefault(require("ioredis"));
/**
 * Extends the Error class with the the error being a combination of status code
 * and text retrieved from the response.
 *
 * @class ResponseError
 * @extends Error
 */
class ResponseError extends Error {
    constructor(response) {
        super(`${response.status} ${response.statusText}`);
        this.response = response;
    }
}
exports.ResponseError = ResponseError;
/**
 * Returns the dto object from the given response object on status codes 2xx and
 * 304 (Not Modified). The fetch library make-fetch-happen returns the cached object
 * on 304 response. This method throws error on any other 3xx responses that are not
 * automatically handled by make-fetch-happen.
 *
 * @remarks
 * Refer to https://en.wikipedia.org/wiki/List_of_HTTP_status_codes for more information
 * on HTTP status codes.
 *
 * @param response - A response object either containing a dto or an error
 * @returns The DTO wrapped in a promise
 *
 * @throws a ResponseError if the status code of the response is neither 2XX nor 304
 */
function getObjectFromResponse(response) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (response.ok || response.status === 304) {
            const text = yield response.text();
            // It's ideal to get "{}" for an empty response body, but we won't throw if it's truly empty
            return text ? JSON.parse(text) : {};
        }
        else {
            throw new ResponseError(response);
        }
    });
}
exports.getObjectFromResponse = getObjectFromResponse;
/**
 * Log request/fetch details.
 *
 * @param resource The resource being requested
 * @param fetchOptions The options to the fetch call
 */
function logFetch(resource, fetchOptions) {
    sdkLogger_1.sdkLogger.info(`Request: ${fetchOptions.method.toUpperCase()} ${resource}`);
    sdkLogger_1.sdkLogger.debug(`Fetch Options: ${JSON.stringify(fetchOptions, 
    // Redis clusters have circular references and can't be converted to JSON
    (key, val) => (val instanceof ioredis_1.default.Cluster ? "<Redis Cluster>" : val), 2)}\nCurl: ${fetch_to_curl_1.default(resource, fetchOptions)}`);
}
exports.logFetch = logFetch;
/**
 * Log response details.
 *
 * @param response The response received
 */
exports.logResponse = (response) => {
    const successString = response.ok || response.status === 304 ? "successful" : "unsuccessful";
    const msg = `Response: ${successString} ${response.status} ${response.statusText}`;
    sdkLogger_1.sdkLogger.info(msg);
    sdkLogger_1.sdkLogger.debug(`Response Headers: ${JSON.stringify(response.headers.raw(), null, 2)}`);
};
/**
 * Makes an HTTP call specified by the method parameter with the options passed.
 *
 * @param method - Type of HTTP operation
 * @param options - Details to be used for making the HTTP call and processing
 * the response
 * @returns Either the Response object or the DTO inside it wrapped in a promise,
 * depending upon options.rawResponse
 */
function runFetch(method, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const resource = new resource_1.Resource(options.client.clientConfig.baseUri, options.client.clientConfig.parameters, options.path, options.pathParameters, options.queryParameters).toString();
        // Lets grab all the RequestInit defaults from the clientConfig
        const defaultsFromClientConfig = {
            cacheManager: options.client.clientConfig.cacheManager,
            retry: options.client.clientConfig.retrySettings,
        };
        // Let's create a request init object of all configurations in the current request
        const currentOptionsFromRequest = {
            method: method,
            retry: options.retrySettings,
            body: JSON.stringify(options.body),
        };
        // Merging like this will copy items into a new object, this removes the need to clone and then merge as we were before.
        let finalOptions = lodash_1.default.merge({}, defaultsFromClientConfig, currentOptionsFromRequest);
        // Headers are treated separately to be able to move them into their own object.
        const headers = new minipass_fetch_1.Headers(lodash_1.default.merge({}, options.client.clientConfig.headers));
        // Overwrite client header defaults with headers in call
        for (const [header, value] of Object.entries(options.headers || {})) {
            headers.set(header, value);
        }
        finalOptions["headers"] = headers;
        // This line merges the values and then strips anything that is undefined.
        //  (NOTE: Not sure we have to, as all tests pass regardless, but going to anyways)
        finalOptions = lodash_1.default.pickBy(finalOptions, lodash_1.default.identity);
        // Convert Headers object into a regular object. `http-cache-semantics`, a
        // package used by `make-fetch-happen` to manipulate headers expects headers
        // to be regular objects.
        finalOptions.headers = lodash_1.default.fromPairs([...headers]);
        logFetch(resource, finalOptions);
        const response = yield make_fetch_happen_1.default(resource, finalOptions);
        exports.logResponse(response);
        return options.rawResponse ? response : getObjectFromResponse(response);
    });
}
/**
 * Performs an HTTP GET operation with the options passed.
 *
 * @param options - Details to be used for making the HTTP call and processing
 * the response
 * @returns Either the Response object or the DTO inside it wrapped in a promise,
 * depending upon options.rawResponse
 */
function _get(options) {
    return runFetch("get", options);
}
exports._get = _get;
/**
 * Performs an HTTP DELETE operation with the options passed.
 *
 * @param options - Details to be used for making the HTTP call and processing
 * the response
 * @returns Either the Response object or the DTO inside it wrapped in a promise,
 * depending upon options.rawResponse
 */
function _delete(options) {
    return runFetch("delete", options);
}
exports._delete = _delete;
/**
 * Performs an HTTP PATCH operation with the options passed.
 *
 * @param options - Details to be used for making the HTTP call and processing
 * the response
 * @returns Either the Response object or the DTO inside it wrapped in a promise,
 * depending upon options.rawResponse
 */
function _patch(options) {
    return runFetch("patch", options);
}
exports._patch = _patch;
/**
 * Performs an HTTP POST operation with the options passed.
 *
 * @param options - Details to be used for making the HTTP call and processing
 * the response
 * @returns Either the Response object or the DTO inside it wrapped in a promise,
 * depending upon options.rawResponse
 */
function _post(options) {
    return runFetch("post", options);
}
exports._post = _post;
/**
 * Performs an HTTP PUT operation with the options passed.
 *
 * @param options - Details to be used for making the HTTP call and processing
 * the response
 * @returns Either the Response object or the DTO inside it wrapped in a promise,
 * depending upon options.rawResponse
 */
function _put(options) {
    return runFetch("put", options);
}
exports._put = _put;
//# sourceMappingURL=staticClient.js.map